# III - 애플리케이션 계층 프로그래밍

# ch08 - HTTP 클라이언트 작성
- HTTP통신에서 웹 클라이언트는 URL(통합 리소스 식별자)을 웹 브라이저에게 전송하고 웹 서버는 URL에 해당하는 미디어 리소스로 응답한다. 이러한 문맥에서 리소스란 이밎ㅣ, 스타일 시트, HTML문서,
자바스크립트 파일 등을 의미한다.

## HTTP 기초 이해
- HTTP는 클라이언트- 서버 기반의 세션을 갖지 않는 프로토콜이다. 즉, 클라이언트가 서버로 요청을 만들어 보매녀, 서버는 클라이언트에게 응답한다. HTTP는 애플리케이션 계층의 프로토콜이며 
웹상에서 통신하는 기반이 된다. 하위 계층의 전송 프로토콜로 TCP를 사용한다.

### 통합 리소스 식별자
- URL이란 클라이언트가 웹 서버를 찾고 요청된 리소스를 식별하는 데 사용되는 일종의 주소이다. URL은 연결에 사용할 프로토콜을 나타내는 데 필수적으로 필요한 스키마, (선택적)권한 정보, 리소스의 경로,
(선택적)쿼리 파라미터, (선택적)정보 조각 총 다섯 가지로 구분된다. 콜론(:)과 두 개의 슬래시(//)를 이용하여 스키마와 권한 정보를 구분한다. 권한 정보에는 콜론으로 구분된 사용자 이름과 비밀번호로 구성되며
(비밀번호가 없는 경우 콜론을 사용하지 않을 수 있다.), 점미사로 앳 기호(@)를 사용한다. 이후 호스트 네임과 선택적으로 콜론으로 구분된 포트 번호를 기재한다. 리소스의 경로는 슬래시를 사용하여 일련의
정보를 구분한다. 물음표는 쿼리 파라미터의 시작을 알린다. 쿼리 파라미터는 통상적으로 키-값의 한 쌍을 이루고 앰퍼샌드(&)로 구분된다. 해시(#) 뒤에 붙은 정보 조각은 리소스 내의 하위 섹션을 나타내는 식별자이다.
```
scheme://user:password@host:port/path?key1=value1&key2=value2#table_of_contents
```
- 일반적으로 인터넷사에서 사용하는 URL은 최소한 스키마와 호스트 네임만을 포함한다. 

### 클라이언트 리소스 요청
- HTTP 요청은 클라이언트가 서버로 특정한 리소스를 응답하도록 요청하는 메시지이다. HTTP요청은 메서드, 대상 리소스, 헤더와 보디로 구성된다. 메서드는 서버에게 대상 리소스로 무엇을 하려는지에 대한 
의도를 나타낸다. 예를 들어, robots.txt에서 GET메서드는 서버에게 robots.txt 파일 리소스를 전송해달라고 요청하는 것이며, DELETE 메서드는 서버에게 리소스를 삭제해 달라고 요청하는 것이다.
- 요청 헤더에는 전송 요청시 보내는 데이터에 대한 메타데이터가 포함된다. 예를 들어, Content-Length 헤더는 요청 보디의 바이트 크기를 나타낸다. 요청 보디(request body)는 요청의 페이로드이다.

### 서버 응답
- 클라이언트의 요청은 항상 메서드와 대상 리소스를 지정해 주는 반면 웹 서버의 응답에는 클라이언트의 오청에 대한 상태를 알려 주는 상태 코드 정보를 항상 포한한다. 요청에 대해 성공적으로 응답하는
경우 200번 대역의 상태 코드로 응답한다. 클라이언트가 서버로 보낸 요청에 대해 클라이언트 측에서 추가로 무언가를 해야 하는 경우 서버는 300번 대역의 상태 코드를 응답한다. 예를들어, 클라이언트의 
마지막 요청 이후 변화되지 않은 리소스에 대해 다시 서버로 요청한다면, 서버는 클라이언트에게 304 상태 코드를 반환하여 캐싱된 리소스를 사용하도록 한다.
- Go는 net/http 패키지 내에 이러한 상태 코드를 상수 값으로 정의한다. 그러므로 코드상에 직접 숫자로 상태 코드를 사용하지 말고 패키지 내의 상수 값을 사용하길 권장한다.
200이 무슨 의미인지 기억하기보다 http.StatusOK 상수 값을 읽는 게 더 쉽다. 흔하게 접할 수 있는 상태 코드는 다음과 같다.
- 200 OK : 요청이 성공함. 요청 메서드가 GET인 경우 응답 보디는 대상 리소스를 포함한다.
- 201 Created
- 202 Accepted : 요청이 성공하였으나 서버가 아직 새로운 리소스를 생성하지 못한 경우 종종 응답되는 코드이다. 
- 204 No Content : 요청이 성공했지만 응답 보디가 비어 있는 경우 종종 응답되는 코드이다.
- 304 Not Modified: 클라이언트가 요청한 리소스가 변경되지 않은 경우 응답코드이다.
- 400 Bad request : 어떠한 이유로 서버가 명백하게 클라이언트의 요청을 거절하는 경우 응답되는 코드이다. 요청 메서드는 존재하지만 대상 리소스를 지정하지 않은 경우와 같이, 요청 자체가 잘못된 경우에 서버는 400상태 코드를 보낸다.
- 403 Forbidden : 서버가 요청을 수락했지만 사용자에게 요청한 리소스에대한 접근 권한이 없는 경우, 혹은 서버가 해당 리소스에 접근할 수 없을 때 보내는 상태코드이다.
- 404 Not Found : 존재하지 않는 리소스를 요청한 경우 응답되는 코드이다. 보통 권한문제로 접근이 불가한 경우에도 404 상태 코드를 보내기도 한다. 이는 공격자로하여금 대상 리소스가 존재하지 않다고
생각하게 하므로 보안이 강화될 수 있다.
- 405 Method Not Allowed : 
- 426 Upgrade Required
- 500 Internal Server Error
- 502 Bad Gateway : 
- 503 Service Unavailable :
- 504 Gateway Timeout

## Go에서 웹 리소스 가져오기
- 웹 브라우저와 마찬가지로 Go에서는 net/http 패키지의 HTTP 클라이언트를 사용하여 웹 서버와 통신할 수 있다. 웹 브라우저와는 달리 Go는 화면에 HTML 페이지를 직접 렌더링해 주지 않는다.
대신에 Go를 이용하여 주식 정보와 같은 웹사이트로부터 데이터를 스크래핑하거나, 폼 데이터를 제출하거나, 애플리케이션 계층 프로토콜로 HTTP를 사용하는 API와 통신을 하는 데 사용할 수 있다.

#### Go의 기본 HTTP 클라이언트 이용하기
- net/http 패키지는 일회성으로 HTTP 요청을 할 수 있는 기본 클라이언트를 포함한다. 예를 들어 http.Head함수를 이용하여 주어진 URL로 Head 요청을 보낼 수 있다.
- [/getTimeClient] 웹 서버로부터 현재 시간을 얻어 온 후 컴퓨터의 로컬 타임과 비교하는 방법을 소개한다. 이 예시에서는 HEAD 요청과 응답을 사용하여 Go HTTP 클라이언트 워크플로를 보여준다.

#### 응답 보디 닫기
- HTTP/1.1은 클라이언트가 서버와의 TCP연결을 유지하여 여러 개의 HTTP 요청을 유치할 수 있는 기능이 존재한다.(이 기능을 킵얼라이브라 한다.). 그럼에도 클라이언트는 이전 응답으로부터 읽지 않은 바이트가 존재하면 TCP 세션을 재사용할 수 없다. Go의 HTTP 클라이언트는 응답 보디를 닫으면 자동으로 모든 바이트를 소비하여 재사용할 수 있게 한다. 따라서 모든 응답 보디를 닫는 것은 TCP 세션을 재사용하기 위해 중요하다.
- HTTP 요청을 하였는데 명시적으로 응답 보디를 소비해야 하는 경우, 가장 효율적인 방법은 io.Copy 함수를 이용하는 것이다. io.Copy 함수는 response.Body의 모든 바이트를 읽어서 ioutil.Discard에 전부 쓰는 형태로 응답 보디를 모두 소비한다. 이름에서 알 수 있듯이 ioutil.Discard 함수는 쓰는 모든 데이터를 버려 버리는 특별한 io.Writer이다.
```
_, _ = io.Copy(ioutil.Discard, response.Body)
_ = response.Close()
```

#### 타임아웃과 취소 구현
- Go의 기본 HTTP 클라이언트와 http.Get, http.Head, http.Post 헬퍼 함수에서 생성된 요청은 타임아웃되지 않는다. 이러한 사실은 심각한 문제에 부딪히기 전까지는 그리 와닿지 않는다. 하지만 부딪히고 나면 절대 잊지 못한다. 타임아웃이나 데드라인이 없다는 말은 곧 오작동하거나 악의적으로 작동하는 서비스로 인해 코드가 에러를 발생하지 않고 무한정 블로킹되어 모든 게 잘못될 수 있다는 의미이다.[/unlimitBlock]
- 타임아웃을 추가한 클라이언트 코드.[/withTimeout]

#### 영속적 TCP 연결 비활성화
- 기본적으로 Go의 HTTP 클라이언트는 응답을 읽은 후에 명시적으로 서버로의 연결을 끊으라고 하지 않으면 하위에 존재하는 웹 서버로의 TCP 연결을 계속해서 유지한다. 대부분의 경우에는 여러 요청에 대해 동일한 TCP 연결을 사용할 수 있기에 이러한 동작을 사용하는 것이 옳을 수 있지만, 자칫 컴퓨터가 다른 웹 서버로 TCP 연결을 맺지 못할 수 있다. 그 이유는 컴퓨터가 유지할 수 있는 활성 상태의 TCP 연결의 개수가 유한하기 때문이다. 가령 내 컴퓨터에서 여러개의 서버로 하나의 요청을 보내는 프로그램을 작성했을 때, TCP 연결을 다 소진하고 나면 프로그램이 기대한 대로 동작하지 않고 새로운 연결을 맺지 못할 수 있다. 
```
--- 생략 ---

req, err := http.NewRequestWithContext(ctx, http,MethodGet, ts.URL, nil)
if err !=nil {
    fmt.Println(err)
    return
}
req.Close = true

--- 생략 ---

```

- 요청의 Close 필드를 true로 두어 Go의 HTTP 클라이언트가 웹 서버의 응답을 읽고 난 후 하위에 존재하는 TCP 연결을 닫도록 한다. 가령, 웹 서버로 총 네 개의 요청을 전송한다면, 네 번째 요청을 보낸 후에 Close 필드값을 설정하면 될 것이다. 네 개의 요청이 동일한 TCP 세션을 사용할 것이며, 클라이언트는 네 번째의 응답을 받고 난 후 TCP 연결을 종료한다.

## HTTP로 데이터 전송하기
- 
