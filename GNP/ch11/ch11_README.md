# Ch11 - TLS를 사용한 통신 보안 // TLS(Transport Layer Security, 전송 계층 보안)
지금까지는 코드를 작성한 이후에 TLS를 적용시켰다. 이는 주로 Go의 net/http 라이브러리를 사용하면 TLS 적용이 굉장히 쉽기도 한 이유도 있지만, 또한 아직까지 TLS 프로토콜과 내부구조에 대해 제대로 알아보지 않았기 때문이다. 안전한 소프트웨어를 작성하기 위하여 개발을 시작하기 이전에 보안에 대한 계획을 세우고 코드를 작성하며 계획대로 보안 실전 사례들을 적용해야 한다. TLS는 전송 중인 데이터를 보호하여 소프트웨어의 보안을 향상하는 데 최적의 방법이다.


## 전송 계층 보안 심층 탐구
- TLS 프로토콜은 클라이언트와 서버 간에 안전한 통신을 제공한다. TLS는 클라이언트가 정말로 올바른 서버에서 온 것인지 인증할 수 있게 해 주며, 또한 선택적으로 서버에서 정말 올바른 클라이언트인지 인증할 수 있다. 클라이언트는 TLS를 사용하여 서버와의 통신을 암호화하여 제3자가 중간에서 통신을 가로채거나 조작할 수 없도록 한다. TLS는 특정한 조건을 만족하는 상태가 있는 TLS 세션을 수립하기 위해 핸드셰이크 프로세스를 사용한다. 클라이언트가 서버와 TLS 1.3 핸드셰이크를 시도하는 경우 대략 다음과 같이 동작한다.
1. 클라이언트 : 안녕하세요, google.com. 버전 1.3의 TLS를 사용하여 당신과 통신하고 싶습니다. 메시지를 암호화하기 위해 사용할 수 있는 암호화 방식의 목록은 다음과 같습니다. 이 대화를 위해 공개키와 비밀키를 만들었습니다. 제 공개키를 보내드립니다.
2. 서버 : 안녕하세요, 클라이언트. 버전 1.3의 TLS라면 통신이 가능합니다. 보내주신 암호와 방식들을 보니 AES-GCM 암호화를 사용하면 좋을 것 같습니다. 제 공개키와 인증서를 보내 드릴 테니 제가 정말 google.com인지 확인해주세요. 그리고 사용하시기로 한 TLS 버전 정보의 32바이트 값을 같이 전송합니다. 마지막으로, 제가 보낸 응답의 무결성을 검증할 수 있도록 당신의 공개키로부터 시그니처와 함께 메시지 인증 코드를 보내 드립니다.
3. 클라이언트(스스로) : 내가 신뢰하는 인증기관이 서버의 인증서를 신뢰하고 있으니 google.com이 맞겠다. 내 비밀키를 이용하여 서버의 시그니처로부터 이 대화에서 사용할 대칭키를 만들어서 서버가 보 준 응답을 살펴보니 메시지 인증 코드에도 문제가 없네, 응답으로 온 32바이트 역시 TLS 1.3인 걸 보면 중간에 누군가 데이터를 가로채서 보안에 취약한 버전의 TLS 버전으로 낮추지도 않았으니 서버와 안전하게 통신할 준비를 마쳤다.
4. 클라이언트(서버에게) : 암호화된 데이터를 보냅니다.

- 서버가 초기 핸드셰이크 과정(hello 메시지)에서 32바이트 값을 보내는 이유는 악의적인 공격자가 클라이언트의 핸드셰이크 과정을 가로채서 보안에 취약한 TLS 버전으로 다운그레이드하는 것을 막기 위함이다. 
- 이 가상의 예시에서는 이 시점 이후로 서버와 클라이언트간에 AES-GCM 대칭 암호화 키를 이용하여 통신한다. 클라이언트와 서버 모두 애플리케이션 계층의 페이로드를 전송 계층으로 전달하기 전에 페이로드를 TLS로 캡슐화한다.
- 이름과 달리 TLS는 전송 계층의 프로토콜이 아니다. 대신 TCP/IP 스택에서 전송 계층과 애플리케이션 계층의 중간에 있다. TLS는 애플리케이션 계층의 페이로드를 전송 계층으로 전달하기 전에 페이로드를 암호화한다. 페이로드가 목적지에 도달하고 나면 
전송 계층으로부터 TLS로 암호화된 패킷을 얻어서 복호화한 뒤 페이로드를 애플리케이션 계층의 프로토콜로 전달한다.

#### 순방향 보안
#### 신뢰하는 인증기관
#### TLS의 보안을 무력화하는 방법

## 전송 중인 데이터의 보안
어느 데이터든지 간에 네트워크를 통해 전송하는 데이터의 무결성을 보장하는 것이 중요하다. Go는 아주 간편하게 TLS를 지원하므로 사용하지 않을 이유가 없다. 이번 섹션에서는 클라이언트 사이드와 서버 사이드에 TLS를 사용하는 방법에 대해 알아겠다.
또한 TCP 상에서 TLS가 동작하는 원리와, 인증서 고정을 통해 악의적인 인증서의 보안 공격을 완화하는 방법에 대해 알아보겠다.

#### 클라이언트 사이드 TLS
- [tls/tls_client_test.go] 클라이언트가 핸드셰이크 프로세스에서 이루고자 하는 바는 인증서를 이용하여 서버를 인증하는 것이다. 클라이언트가 서버를 신뢰할 수 없다면, 당연하게도 서버와의 통신 또한 안전하지 않다. net/http/httptest 패키지에서
제공하는 함수를 이용하면 Go에서 HTTP상에서의 TLS 지원을 쉽게 테스트해 볼 수 있다.

#### TCP 상에서의 TLS
- TLS는 스테이트풀하다. 즉, 클라이언트와 서버가 최초 핸드셰이크 과정에서 세션 매개변수를 현상하고 나면 그 이후 세션이 살아 있는 동안 협상된 대로 암호화된 TLS 정보를 주고받는다. TCP 또한 스테이트풀 하기 때문에 전송 계층에서 TLS를 구현하기에 이상적이다. 
또한 TCP의 신뢰성을 이용하여 TLS세션을 유지할 수 있다.
- 애플리케이션 계층의 프로토콜은 잊고, TCP상에서 TLS 연결이 수립되는 과정에 대해 알아보겠다. [tls/tls_client_test.go] 코드에ㅅ crypto/tls 패키지를 이용하여 몇 줄의 코드로 TLS 연결을 초기화한다.
```
// 해당 테스트코드 함수만 실행하는 명령어
$ go test -race -run TestClientTLSgoogle -v ./
```

#### 서버 사이드 TLS
- 서버 사이드의 코드는 지금까지 배운 코드와 크게 다르지 않다. 주요 차이점은 서버가 핸드셰이크 프로세스에서 클라이언트에게 인증서를 제공해야 한다는 것이다. Go가 설치된 디렉터리 하위의 src/crypto/tls 서브디렉터리 내에 존재하는 generate_cert.go 파일을 이용하여 사설 인증서를 생성할 수 있다. 프로덕션 서비스에서는 Let's Encrypt에서 획득한 인증서나 다른 인증 기관으로부터 획득한 인증서를 사용하는 것이 낫다. LEGO 라이브러리를 이용하여 개발중인 서비스에 인증서 관리를 할 수 있다. 다음의 명령어로 새로운 인증서와 개인키를 생성하자.
```
# 우분투 환경에서 해당 디렉터리는 /usr/local/go/src/... 에 있다.
$ go run $GOROOT/src/crypto/tls/generate_cert.go -host localhost -ecdsa-curve P256
```

-  이 명려어는 localhost의 호스트 네임과 key.pem이라는 이름을 가진 파일의 개인키를 사용하여 cer.pem이라는 이름을 가진 파일의 인증서를 생성한다. 이 섹션의 나머지 코드에는 개인키와 인증서 두 파일이 현재 디렉터리에 있다고 가정한다.
- [tls_echo/tls_echo.go] 예제는 TLS만을 사용한 에코 서버 코드이다.