# PART IV 서비스 아키텍처
# Ch12 - 데이터 직렬화
- 다른 프로그래밍 언어로 작성된 서비스 간에도 사용할 수 있도록, 서비스 간에 통신으로 데이터를 주고받거나 저장하고 읽어 오기 위한 목적으로 데이터 직렬화를 사용하는 방법에 대해 알아보겠다.
- 다양한 직렬화 포맷이 있지만, Go 네트워크 프로그래밍에서 가장 많이 사용되는 JSON과 프로토콜 버퍼, 그리고 Gob 포맷에 대해 살펴본다.
- gRPC라 부르는 프레임워크를 사용하여 원격 노드에 존재하는 코드를 실행하는 방법에 대해서 알아보겠다.
- 이번 장을 통해서 스토리지에 데이터를 저장하거나 네트워크에 데이터를 전송하기 위해 객체를 직렬화하는 방법, 그리고 직렬화된 데이터를 의미 있는 데이터 구조로 디코딩하는 방법에 대해 알게 될 것이다. 
- 네트워크를 통해 복잡한 데이터를 주고받는 서비스를 구현하거나, 이미 존재하는 네트워크 서비스 간에 통신하는 코드를 작성할 수 있다.

## 객체 직렬화하기
- 객체, 혹은 구조화된 데이터는 그 자체로 네트워크 연결을 통해 전송될 수 없다. 즉, net.Conn의 Write 메서드의 매개변수로는 바이트 슬라이스만 전달할 수 있으며, 객체를 전달할 수 없다. 따라서 객체를 바이트 슬라이스로 직렬화해야 Write 메서드의 매개변수로 전달할 수 있다. Go에서는 데이터 직렬화가 그리 어렵지 않다.
- encoding 패키지를 사용하면 객체를 대부분의 필요한 데이터 포맷으로 직렬화할 수 있다. encoding/binary 패키지를 이용하면 숫자를 바이트 시퀀스로 직렬화 할 수 있으며, encoding/json 패키지를 이용하면 객체를 HTTP로 전송하기에 적합한 JSON으로 직렬화할 수 있고, encoding/pem 패키지를 이용하면 TLS 인증서와 개잍키를 파일로 직렬화할 수 있다. 
- 어떠한 함수나 메서드의 이름에 encode나 marshal이 포함되어 있으면 아마도 그 용도는 데이터 직렬화일 것이다. 마찬가지로 이름에 decode나 unmarshal이 포함되어 있으면 데이터를 역직렬화한다.
- 이 섹션에서는 데이터를 JSON과 프로토콜 버퍼, 그리고 Gob의 세 가지의 바이너리 인코딩 포맷으로 직렬화하는 애플리케이션을 작성해보겠다.
- 예제로 집안일 애플리케이션을 작성해보겠다.
- [housework/housework.go] - 집안일을 나타내기 위한 타입 
```
package housework

type Chore struct {
    Complete    bool
    Description string
}
```
- [cmd/housework.go] - 집안일 애플리케이션 : 집안일의 구조체를 사용해서 커맨드 라인에서 집안일을 관리하는 애플리케이션이다. 집안일의 목록과 현재 상태를 보여주고, 목록에 집안일을 추가하고, 끝낸 집안일을 완료했다고 마킹한다.

#### JSON
- [json/housework.go]코드는 encoding/json 패키지를 사용해서 JSON 스토리지를 구현한다.

#### Gob
- 'gobs of binary data'(바이너리 데이터 덩어리)라는 의미의 Gob은 Go의 네이티브 바이너리 직렬화 포맷이다. Go 팀의 엔지니어들은 가장 유명한 바이너리 직렬화 포맷인 프로토콜 버퍼의 효율성과 JSON의 쉬운 사용성을 통합하기 위해 개발하였다. 예를 들어, 프로토콜 버퍼는 JSON처럼 새로운 인코더를 만든 뒤 객체를 넣어서 쉽게 인코딩할 수 없다. 반면에 Gob은 똑똑하게 객체의 구조를 파악하고 직렬화할 수 있기 때문에 Gob은 JSON 인코더와 매우 유사하게
- [gob/housework.go]코드에서 집안일 애플리케이셔의 스토리지 백엔드를 Gob으로 구현한다. Gob은 JSON을 사용하는 것처럼 간단하게 사용할 수 있다.
- hexdump 도구를 사용하면 godData.db 파일에 바이너리 데이터를 확인할 수 있다. JSON처럼 사람이 읽을 수 있는 형태는 아니지만, Go는 Gob으로 인코딩된 데이터를 디코딩할 수 있다. 만일 어떤 Go 서비스가 Gob을 지원한다면 Gob을 사용하는것이 성능이 더 좋다. 또한 JSON보다 더욱 적은 공간을 사용하기에 간경하며, 데이터를 저장하거나 전송할 때 이점이 있다.

#### 프로토콜 버퍼(proto3 버전)
- 프로토콜 버퍼는 Gob처럼 바이너리 인코딩을 사용하여 다양한 플랫폼에서 정보를 저장하고 교환하는 데 사용하는 직렬화 포맷이다. 프로토콜 버퍼는 Go의 JSON 인코딩보다 더욱 빠르고 간결하지만, Gob과는 달리 프로토콜 버퍼는 JSON처럼 언어에 종속적이지 않으며, 대다수의 프로그래밍 언어에서 지원된다. 이런 특성때문에 Go기반의 서비스를 다른 언어로 작성된 서비스와 통합할 때 사용하기에 이상적이다.
- 프로토콜 버퍼는 .proto 확장자를 갖는 별도의 파일에 메시지를 정의한다. 메시지는 데이터를 저장하거나 전송하기 위해 직렬화할 구조화된 데이터이다. 예를 들어, 집안일 타입을 나타내는 프로토콜 버퍼 메시지는 다음과 같다.
```
message Chore {
    bool complete = 1;
    string description = 2;
}
```
- message 키워드와 메시지를 식별하는 고유 이름으로 새로운 메시지를 정의한다. 프로토콜 버퍼 메시지의 네이밍 컨벤션으로 파스칼 케이스를 사용한다(단어별 첫  글자를 대문자로 이어 붙이는 포맷). 그리고  Chore 메시지에 필드를 추가한다. 각 필드의 정의에는 타입, 네이밍 컨벤션으로는 카멜케이스를 사용한(camelCaseNamingConvention) 이름, 그리고 메시지에 고유한 필드 번호를 사용한다.
필드의 타입과 필드 번호는 바이너리 페이로드에서 필드를 고유하게 식별하는 식별자가 되기 때문에 한번 사용된 다음에 변경하면 하위 호환성이 깨지게 된다. 하지만 이미 존재하는 .proto 파일에 새로운 메시지와 메시지 필드를 추가하는 것은 문제가 없다.
- 하위 호완성과 관련하여 프로토콜 버퍼 정의와 API를 동일하게 취급하는 것이 좋다. 어떤 서드파티가 우리가 개발한 프로토콜 버퍼 정의를 이용하여 서비스와 통신해야 한다면, 정의 파일 자체를 버전 관리해야 된다. 이렇게 프로토콜 버퍼 정의 파일을 버전 관리하면 하위 호환성을 깨야 할 필요가 있을 때 그냥 새로운 버전을 만들면 된다. 개발은 최신 버전대로 진행하면 되고, 모든 클라이언트가 최신 버전을 사용할 때까지는 계속해서 이전 버전을 사용하면 된다. 
- 애플리케이션에서 프로토콜 버퍼를 사용하려면 먼저 .proto 파일을 컴파일하여 Go 코드를 생성해야 된다. 생성된 코드를 사용하면 .proto 파일에 정의된 메시지를 Go에서 직렬화 하거나 역직렬화할 수 있다. 그리고 프로토콜 버퍼를 사용하기 전에 먼저 프로토콜 버퍼 컴파일러와 Go 코드 생성 모듈을 설치해야 한다. 
```
$ sudo apt install protobuf-compiler
$ GO111MODULE=on go get -u github.com/golang/protobuf/protoc-gen-go -> 이건 없어도 되는 것도 같고..
$ sudo apt install proto-gen-go // 이렇게 설치하면 proto-gen-go를 실행가능하다.
```

- [/housework/v1/housework.proto] 코드를 작성하고 Go 코드로 컴파일한다.
```
go 컴파일 명령어는 해당 소스 폴더에서 아래 명령을 실행하면 housework.pb.go 파일이 생성된다.
$ protoc --go_out=. --go_opt=paths=source_relative housework.proto
```
- 생성된 파일을 head 명령으로 살펴보면 아래와 같다
```
$ head -n 15 housework.pb.go 
//proto3 버전 문법을 사용하는 것을 지정한다.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.32.0
// 	protoc        v3.21.12
// source: housework.proto

//생성된 코드의 패키지명 지정

package housework

$ 
```
- 주석 내용에 따라서 이 모듈을 수정해서는 안되며 필요한 경우 .proto 파일을 수정하고 다시 컴파일해야 된다.
- 이제 .proto 파일에서 go모듈을 생성했으니, 프로토콜 버퍼를 사용해서 스토리지 백엔드를 구현해보겠다.
- [/protobuf/housework.go]
##### 이때 기억해야 되는 것은 프로토콜 버퍼를 사용하는 경우 storage가 프로토콜 버퍼로 코드를 작성해서 Go로 컴파일한 코드로 바뀌게 된다. 이 예제에서는 json이나 Gob을 사용하는경우 집안일 타입은 [/housework/housework.go]를 사용학지만 프로토콜 버퍼를 사용하는 경우 집안일 타입은 [/housework/v1/housework.pb.go]로 바꿔서 사용해야 된다.

## 직렬화된 객체 전송하기
- 직렬화된 객체는 파일 시스템에 저장하기도하지만, 보통은 네트워크 서비스에서 더욱 많이 이용한다. 예를들어 온라인 상점에서는 고객의 장바구니, 계정 정보, 결제 정보, 배송 정보 및 알림 서비스 등을 위한 웹 서비스가 존재한다. 이러한 서비스들이 동일한 서버 내에 존재한다면 사업이 확대됨에 따라 더욱 고성능의 서버를 구매해야 된다. 확장성을 위한 또 다른 방법으로는 각각의 서비스를 각 고유의 서버에 운영하고 서버의 대수를 늘리는 것이다. 
그러면 새로운 문제가 발생한다. 서비스들이 동일한 서버 내에 존재하지 않으니 동일한 메모리를 사용하지 않는 상황에서, 다른 서버 간의 데이터를 어떻게 공유할 수 있을까?
거대 기술 기업들은 이러한 문제를 RPC(Remote Procedure Call, 원격 프로시저 호출)라는 방법으로 해결한다. RPC란 클라이언트가 원격에 존재하는 서버의 서브루틴을 호출할 수 있는 기술이다. 애플리케이션의 관점에서 볼 때 RPC 서비스는 동일한 서버 내에 존재하는 것처럼 보이지만, 실제로는 네트워크상의 여러 서버 내에 분산되어 있다. 코드상에서는 함수를 호출하고, 함수 내에서는 메시지를 서버로 전송한다. 메시지를 받은 서버는 함수를 실행하고 결괏값을 함수에게 응답하며, 함수는 서버에서 실행되어 응답된 결과를 반환한다. 코드의 관점으로 볼 때 함수는 실제로 RPC가 서버와 통신하는 것과 상관없이 하나의 노드에서 지역적으로 동작한다. 즉, 작성한 코드는 하나의 노드에서 지역적으로 동작하든 네트워크상에서 동작하든 상관없이 동일하게 동작한다.

- 최근 대다수의 기업은 gRPC를 사용하여 RPC를 구현한다. gRPC란 HTTP/2와 프로토콜 버퍼를 활용한 크로스 플랫폼 RPC 프레임워크이다. 이제 gRPC를 활용하여 집안일 애플리케이션보다 조금 더 정교한 것을 만들어 보겠다. 만들어 볼 서비스는 해야 할 일을 로시(Rosie)에게 전송하는 서비스이다. 로시는 집안일을 책임지는 고전 애니메이션 시리즈 '젯슨 가족'의 로봇 메이드이다.

#### gRPC로 서비스 연결하기
gRPC 프로엠워크는 많은 RPC 세부 구현을 추상화한 라이브러리들의 집합이다. 플랫폼에 중립적이며 프로그래밍 언어에도 독립적이다. 즉, gRPC를 사용하면 Windows에서 동작중인 Go언어로 개발된 서비스와 리눅스에서 동작 중인 Rust로 개발된 서비스를 통합할 수 있다.