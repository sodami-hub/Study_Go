# ch-09 HTTP 서비스 작성
- 요청을 처리하고 클라이언트에게 리소스를 보낼 수 있는 서버를 작성한다. net/http 패키지가 대부분의 세부사항을 처리해 주므로 서버를 초기화하고 설정하고, 리소스를 생성하고, 클라이언트가 보내는 요청을 처리하는 데에 집중할 수 있다.
- Go에서 HTTP서버는 서로 활발하게 통신하는 여러 요소에 의존한다. 여려 요소란 핸들러와 미들웨어, 그리고 멀티플렉서를 의미한다. 웹 서비스란 이 모든 요소를 포함하는 서버이다. 이번 장에서는 먼저 간단한 HTTP 웹 서비스를 살펴본 후 각 요소들에 대해 알아보겠다. 또한, net/http 패키지를 사용하여 TLS를 지원하거나 HTTP/2 클라이언트에 데이터를 푸시하는 동의 고급 사용법에 대해 알아본다. 이번 장의 내용을 잘 숙지하면 Go 기반의 HTTP 서버를 설정하고 미들웨어를 작성하고 핸들러를 사용하여 사용자의 요청에 응답하는 것에 익숙해질 것이다.

## Go HTTP 서버 해부
- 아래 그림은 일반적인 net/http 기반의 서버가 요청을 처리하는 과정을 보여준다.
![클라이언트의 요청이 서버에서 처리되어 핸들러에서 응답되는 과정](./go_reqAndresp.jpeg)
1. 먼저 서버의 멀티플렉서(컴퓨터 네트워킹 용어로는 라우터router)는 클라이언트의 요청을 수신한다. 
2. 멀티플렉서는 요청의 목적지를 결정한 후 해당 요청을 처리할 수 있는 능력이 있는 객체로 클라이언트의 요청을 전달한다. 이 객체를 핸들러(handler)라 부른다. 멀티플렉서 또한 클라이언트의 요청을 받아 적절한 핸들러로 넘겨주는 하나의 핸들러이다.
3. 핸들러가 요청을 넘겨받기 전, 멀티플렉서는 먼저 요청을 미들웨어라 불리는 하나 이상의 함수로 전달한다. 미들웨어는 핸들러의 동작을 변경하거나 로깅, 인증 및 접근 제어 등의 부가적인 작업을 수행한다.
- [/server] 예제에는 HTTP 서버와 멀티플렉서를 초기화하는 코드, 그리고 [/client]에는 앞의 서버로 요청을 보내는 클라이언트 코드가 있다.

### 클라이언트는 서버의 시간을 신경쓰지 않음
- 클라이언트의 타임아웃 값 뿐 아니라 서버의 다양한 타임아웃 값들도 관리해 주어야 한다. 클라이언트는 서버의 시간을 신경쓰지 않기 때문이다. 클라이언트는 그저 서버로 요청을 보내며 응답이 오기를 기다리고 있을 뿐이다. 반면, 서버는 서버 내의 컴퓨팅 자원이나 메모리 등의 리소스를 사용하여 요청 전체를 수신할 때까지 대기한다. 또한 서버는 클라이언트가 응답을 다 받을 때까지 기다려야 한다. 서버가 전송할 수 있는 최대 속도는 클라이언트가 읽을 수 있는 최대 속도만큼이기 때문이다. 따라서 클라이언트가 요청-응답 생명주기를 지정하지 않도록 해야 된다.
- [/server] 예제의 http.Server 인스턴스의 타임아웃과 관련된 두개의 값을 설정했다. IdleTimeout은 클라이언트가 요청 간 유휴 상태로 존재할 수 있는 시간이고, ReadHeaderTimeout은 요청 헤더를 읽는 동안 서버의 대기 시간이다. http.Server 내에 사용할 수 있는 타임아웃과 관련된 필드가 여러 개 존재하지만 위의 두개만 사용하기를 권장한다. 이 두 필드가 지정하는 대기 시간은 실제로 요청 보디를 읽는 데 걸리는 시간과는 무관하다. ReadTimeout, WriteTimeout의 값을 작게 주면 클라이언트가 요청 보디에 큰 파일을 전송하는 핸들러, 혹은 클라이언트에게 지속해서 데이터를 스트리밍해야 하는 핸들러에게는 문제가 된다. 

### TLS 지원하기
- 기본적으로 HTTP 트래픽은 플레인텍스트이지만, 웹 클라이언트와 서버는 암호화된 TLS연결을 이용하여 HTTP를 사용할 수 있다. 이러한 조합을 HTTPS라 부른다. Go의 HTTP 서버에서 HTTP/2 지원은 반드시 TLS 연결을 통해서 가능하지만, TLS를 활성화하는 것은 간단하다. [/server]의 구현에서 포트번호와 Server 메서드, 두 라인만 수정하면 된다.
```
srv := &http.Server{
		Addr: "127.0.0.1:8443",
		Handler: http.TimeoutHandler(
			handlers.DefaultHandler(), 2*time.Minute, ""),
		IdleTimeout:       5 * time.Minute,
		ReadHeaderTimeout: time.Minute,
	}

	l, err := net.Listen("tcp", srv.Addr)
	if err != nil {
		fmt.Println(err)
		return
	}
	go func() {
		err := srv.ServeTLS(l,"cert.pem","key.pem")
		if err != http.ErrServerClosed {
			fmt.Println(err)
		}
	}()
```
- 포트번호를 변경할 필요는 없지만 통상적으로 HTTPS는 443번 포트, 혹은 443에 어떤 숫자를 추가한 형태를 사용한다. 서버의 ServeTLS 메서드를 사용하여 TLS상에서 HTTP를 사용하도록 한다. ServeTLS메서드의 매개변수로 인승서와 개인키의 경로를 지정한다. mkcert 프로젝트(https://github.com/FiloSottile/mkcert/)를 이용하면 개발용으로 사용할 수 있는, 로컬 내에서 신뢰성 있는 키 페어를 생성할 수 있다. 프로덕션 시스템에서는 Let's Encrypt를 사용하여 키페어 얻는 것을 고려해야 한다.

### 핸들러[/handler]
- 클라이언트가 HTTP 서버로 요청을 보내면 서버는 먼저 그 요청으로 무엇을 할지 파악해야 한다. 서버는 클라이언트의 요청에 따라 다양한 리소스를 받아와야 할 수도 있고, 혹은 어떠한 동작을 수행해야 할 수도 있다. 이러한 문제를 해결하기 위한 일반적인 디자인 패턴은 핸들러라 부르는, 요청을 처리할 수 있는 코드로 작성하는 것이다. 앞선 '멀티플렉서'를 통해서 서버는 요청에 대한 핸들러를 선택하는 방법을 알아볼 것이다.
- Go에서 핸들러는 http.Handler 인터페이스를 구현한 객체이다. 핸들러는 클라이언트의 요청을 읽고 응답을 쓴다. http.Handler 인터페이스는 요청과 응답 모두 매개변수로 받는 하나의 메서드로 구성된다.


### httptest를 이용하여 핸들러 테스트하기
- Go의 표준 라이브러리에는 net/http/httptest 패키지가 존재한다. 이 패키지를 이용하여 손쉽게 핸들러의 유닛 테스트를 할 수 있다. NewRequest 함수의 매개변수로 HTTP 메서드, 대상 리소스, 그리고 요청 보디의 io.Reader를 전달한다. 그러면 http.Handler에서 사용할 수 있는 http.Request 객체의 포인터가 반환된다.
```
fun NewRequest(method, target string, body io.Reader) *http.Request
```
- http.NewRequest 함수와는 다리게 httptest.NewRequest 함수는 문제가 생기면 에러를 반환하는 대신 패닉한다. 테스트환경이기 때문에 패닉한다.
- httptest.NewRecorder 함수는 http.ResponseWriter 인터페이슬ㄹ 구현한 httptest.ResponseRecorder 객체의 포인터를 반환한다. http.ResponseRecorder 객체에서 사용할 수 있는 일부 필드는 사용하고 싶게 생겼습니다만, 필드를 직접 사용하지말고 Result 메서드를 사용하기를 권장한다. Result 메서드는 다른 장에서 사용했던 것과 같이 http.Response 객체의 포인터를 반환한다. Result 메서드는 이름과 같이 핸들러가 처리되고 
httptest.ResponseRecorder의 결과를 받아 올 때가지 기다린 후에 결과값을 반환한다.
- [/handlers/pitfall_test.go] 에서는 httptest.NewRequest 함수와 httptest.NewRecorder 함수를 사용한다.
- 한 가지 실수할 수 있는 것은 응답 보디를 쓰는 순서와 응답 상태 코드를 올바르게 설정하는 것이 굉장히 중요하다는 것이다. 클라이언트는 서버로부터 먼저 상태 코드를 받은 후에 응답 보디를 받는다. 만약 응답 보디를 먼저 쓰면 Go는 응답 상태 코드를 200이라고 생각하고 실제로 응답 보디를 보내기 전에 클라이언트에게 먼저 보낸다. 이 동작을 알아보기위해서 [/handlers/pitfall_test.go] 예제를 보자.

### 모든 타입은 핸들러가 될 수 있다.
- http.Handler가 인터페이스이기 때문에 이를 이용하여 클라이언트의 요청을 처리할 수 있는 강력한 구조를 작성할 수 있다. [/handlers/methods.go] 예제에서는 http.Handler 인터페이스를 구현한 새로운 타입을 정의하여 기본 핸들러를 개선한다. 이 새로운 타입은 특정한 HTTP 메서드 요청에 대해 올바르게 응답할 수 있고, 자동으로 OPTIONS 메서드를 구현해준다.