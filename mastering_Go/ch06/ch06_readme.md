# 06 - 유닉스 시스템의 작업
- Go에서의 시스템 프로그래밍 : 파일과 디렉터리 다루기, 프로세스 제어, 시그널 처리, 네트워크 프로그래밍, 시스템 및 설정 파일 입출력

### 1. stdin, stdout, stderr
- 유닉스는 프린터나 마우스를 비롯한 모든 것을 파일로 표현하기 때문에 유닉스에서 이 파일에 접근할 때는 양의 정수 값으로 표현하는 파일 디스크립터를 이용한다. 파일 디스크립터는 열린 파일에 접근하기 위한 내부 표현 방식으로, 경로를 길게 적는 것보다 훨씬 깔끔하고 간편하다. 
- 모든 유닉스 윤영체제에는 항상 열려 있는 세 가지 파일이 있다. 기본적으로 /dev/stdin, /dev/stdout, /dev/stderr 라는 세가지 특수 표준 파일명을 사용한다. 각각에 대한 파일 디스크립터는 0,1,2다. 이 세 가지 파일 디스크립터는 표준 입력, 표준 출력, 표준 에러라고 부른다.
- Go 에서 표준 입력은 os.Stdin, 표준 출력은 os.Stdout, 표준 에러는 os.Stderr로 접근한다.

### 2. 유닉스 프로세스
- 프로세스란 명령, 사용자 데이터, 시스템 데이터, 실행 시간 동안 얻은 다양한 리소스로 구성된 실행 환경이다.
- 프로그램은 명령들과 프로세스에서 초기화할 데이터로 구성된 바이너리 파일이다. 
- 유닉스 프로세스는 실행할 때마다 프로세스 ID라고 부르는 부호 없는 정수 값으로 된 고유 ID가 할당된다.
- 프로세스는 크게 사용자 프로세스, 데몬 프로세스, 커널 프로세스로 나눌 수 있다. 사용자 프로세스는 사용자 공간에서 실행하며 대개 특별한 접근 권한이 필요 없다. 데몬 프로세스는 사용자 공간에서 실행되지만 터미널과 상호작용하지 않고 백그라운드에서 구동한다. 커널 프로세스는 커널 공간에서만 실행하며, 모든 커널 데이터 구조체에 대한 접근 권한이 있다.
- Go 언어 에서는 exec 패키지를 이용해서 새로운 프로세스를 생성할 수 있지만 스레드를 관리하는 기능을 제공하지 않는다. 대신 고루틴을 사용하고 Go 런타임이 스레드 위에서 고루틴들을 관리한다.

### 3. 유닉스 시그널 처리
- 유닉스 시그널을 사용하면 애플리케이션들끼리 비동기적으로 상호작용할 수 있다. 그러나 유닉스 시그널을 처리할 때는 채널을 사용해야 한다. 시그널 처리에는 고루틴과 채널이 필요하므로 Go의 동시성 모델을 살펴보겠다.
- [/signals] 프로그램은 SIGINT와 SIGINFO를 처리한다. Go에서 해당 SIGINT는 syscall.SIGINT로 표현한다. 또한 switch 블록에서 default를 사용해 나머지 시그널들을 처리한다. switch를 통해 여러 가지 시그널에 따라 다른 동작을 수행할 수 있다. 모든 시그널을 전달받는 채널은 signal.Notify() 함수 안에 있다. 채널은 용량을 가질 수 있다. 프로그램을 종료할 때는 동시에 다른 시그널을 처리할 필요가 없으므로 용량이 1이어도 충분하다. 보통은 익명 함수를 고루틴으로 실행해 시그널을 처리한다. 시그널이 들어오면 채널로 시그널이 보내지고 다른 고루틴에서 시그널을 받은 다음 변수로 저장한다.(이때부터 채널에 다른 시그널이 들어올 수 있다.) 시그널을 저장한 변수는 switch 구문으로 처리된다.

### 4. 파일 입출력
- io.Reader, io.Writer 인터페이스, 버퍼를 이용하는 파일 입출력, bufio 패키지를 통해서 Go에서 파일을 입출력하는 방법을 살펴본다.
##### io.Reader, ioWriter 인터페이스
- io.Reader 인터페이스의 정의
```
type Reader interface {
    Read(p []byte) (n int, err error)
}
```
- Reader 인터페이스를 만족하려면 하나의 메서드를 구현해야 한다. Read()의 매개변수는 바이트 슬라이스다. Read()의 반환값은 정수와 에러다.
- Read() 메서드는 바이트 슬라이스를 입력받아 입력된 슬라이스의 길이까지의 데이터를 채운 뒤 읽은 바이트의 개수와 에러를 함께 반환하는 함수다.
- io.Writer 인터페이스의 정의
```
type Writer interface {
    Write(p []byte)(n int, err error)
}
```
- Write() 메서드는 파일에 쓰고자 하는 바이트 슬라이스를 받아서 쓴 바이트의 개수와 에러를 반환한다.

##### io.Reader와 io.Writer의 사용과 오용 [/ioInterface]
##### 버퍼를 이용한 파일 입출력과 버퍼를 이용하지 않는 파일 입출력
- 버퍼를 이용한 파일 입력과 출력은 데이터를 읽거나 쓰기 전에 잠시 버퍼에 저장한다. 따라서 파일은 한 바이트 단위로 읽지 않고 한 번에 여러 바이트를 읽을 수 있다. 데이터를 버퍼에 저장해둔 후 각자 원하는 방식으로 읽는 것이다.
- 버퍼를 사용하지 않는 입출력은 실제로 파일을 읽거나 쓰기 전에 데이터를 임시로 저장하지 않는다.
- 중요한 데이터를 다룰 때는 일반적으로 버퍼를 사용하지 않는 것이 좋다. 버퍼를 거치는 동안 데이터가 더 이상 쓸모없는 상태가 되거나 버퍼에 저장된 사이에 컴퓨터 전원이 꺼지면 데이터를 잃어버릴 수 있기 때문이다. 하지만 버퍼 사용에 대한 기준은 명확하게 하기 어렵다. 따라서 구현하기 쉬운 방식을 사용해야 된다. 
- 그러나 버퍼를 사용하면 파일이나 소켓으로부터 데이터를 읽을 때 시스템 콜을 호출하는 횟수가 줄어들어 성능이 나아진다는 점은 알고 있어야 된다. 
- 또한 bufio 패키지도 있다. bufio 패키지는 버퍼를 사용한 입력과 출력 기능을 제공한다. bufio 패키지는 텍스트 파일을 읽는 데에 매우 널리 사용하며 다음 절에서 알아보겠다.

### 5. 텍스트 파일 읽기
- 텍스트 파일을 읽는 방법과 난수를 얻는 데 /dev/random 유닉스 장치를 사용하는 방법을 알아본다.
##### 줄 단위로 텍스트 파일 읽기[/lineByLine]
##### 단어 단위로 텍스트 파일 읽기[/wordByWord]
- 정규표현식을 사용해서 각 줄에 있는 단어를 구분한다. 전규표현식은 regexp.MustCompile("[^\\s]+")로 정의한다. 공백 문자를 구분자로 사용해 단어를 나눈다.
##### 문자 단위로 텍스트 파일 읽기[/charByChar]
- 읽어 들인 각 줄을 for 루프와 range를 이용해서 반복한다. 
##### /dev/random 읽기[/devRandom]
- /dev/random 시스템 장치는 랜덤 데이터를 생성하고자 존재하며 이로부터 만들어진 결과는 프로그램을 테스트하거나 난수 생성기의 시드로 활용할 수 있다.
- /dev/random 에서 데이터를 가져오는 것은 약간 까다롭기에 여기서 따로 설명한다.
##### 파일에서 원하는 만큼만 데이터 읽기[/readSize]
- 파일의 작은 일부분만을 보고 싶은 경우에 사용할 수 있는 코드이다.

### 6. 파일 쓰기
- [/writeFile]

### 7. JSON 데이터 처리
##### Marshal(), Unmarshal()[/encodeDecode]
- Go에는 JSON데이터를 다루기 위한 표준 라이브러리인 encoding/json 라이브러리가 있다. 또한 Go는 태그를 이용해 구조체에서 JSON 필드를 지원할 수 있다.(이후에 살펴본다.) 태그를 이용하면 JSON 레코드를 인코딩하거나 디코딩 할 수 있다. 그러나 먼저 JSON 레코드를 마샬링하거나 언마샬링하는 방법부터 알아보겠다.
- 마샬링(Marshaling) : 구조체를 JSON 레코드로 변환하는 과정이다. 보통 JSON레코드 형태로 네트워크를 통해 데이터를 전송하거나 디스크에 저장할 때 사용한다.
- 언마샬링(Unmarshaling) : 바이트 슬라이스 형태의 JSON 레코드를 구조체로 변환하는 과정이다. 네트워크를 통해 받거나 디스크에 파일로 저장한 JSON 데이터를 코드에서 사용할 때 언마샬링이 필요하다.
##### 구조체와 JSON[/tagsJSON]
- 빈 필드는 JSON에서 제외하고 싶다면 다음 코드처럼 omitempty를 사용한다.
```
type NoEmpty struct {
    Name string `json:"username"`
    Year int    `json:"creationyear,omitempty"`
}
```
- 민감한 데이터를 갖는 필드는 JSON 레코드에 포함시키고 싶지 않다면 "-"값을 사용한다.
```
type NoEmpty struct {
    Name string `json:"username"`
    Year int    `json:"creationyear,omitempty"`
    password string `json:"-"`
}
```
##### 스트림 형태로 JSON 데이터 읽고 쓰기[/JSONstreams]
- Go는 여러 JSON 레코들르 처리할 수 있도록 스트림 형태로 JSON 데이터를 처리할 수 있는 방법을 제공하는데, 더 빠르고 효율적이다. 
##### JSON 레코드 출력 다듬기[/prettyPrint]
- json의 인코딩 또는 마샬에서 indent를 사용하는 방법을 보여준다.

### 8. XML 데이터 처리[/xml]
- Go 구조체에 XML 관련 태그를 추가해 XML 레코드를 encoding/xml 패키지의 xml.Unmarshal()과 xml.Marshal()을 이용해 관련 필드를 직렬화하거나 역직렬화한다. 하지만 /xml/xml.go 에서 JSON과의 차이점을 살펴볼 수 있다.
##### JSON과 XML변환[/JSON2XML]

### 9. YAML 데이터 처리[/yaml]
- Go 표준 라이브러리는 YAML 파일을 지원하지 않으므로 YAML을 지원하는 외부 라이브러리가 있는지 살펴봐야 된다. 다음 세개의 패키지들이 Go에서 YAML을 다룰 수 있게 해준다.
- https://github.com/kylelemons/go-gypsy
- https://github.com/go-yaml/yaml
- https://github.com/goccy/go-yaml

### 10. viper 패키지
- 플래그(flag)란 프로그램의 동작을 제어하고자 전달하는 특별한 형태의 문자열 값이다. 여러가지 플래그와 옵션을 지원하는 플래그를 직접 구현하는 것은 간단하지 않다. Go에서 제공하는 flag 패키지를 이용하면 커맨드라인 옵션, 매개변수, 플래그를 관리할 수 있다. flag 패키지가 많은 일을 할 수 있지만 외부 패키지만큼 유용하지는 않다. 그러므로 간단한 유닉스 시스템 유틸리티를 개발할 때는 flag 패키지를 사용하는 것이 더 유용하다. 하지만 flg는 건너띄고 유용한 많은 옵션을 제공하는 viper 패키지를 살펴보겠다. 
- viper는 flag 대신 pflag를 사용하고 앞으로 나올 코드에서 살펴본다. 
- 모든 viper 프로젝트는 일정한 패턴을 따른다. 먼저 viper를 초기화한 후 원하는 원소를 정의한다. 그러고 나서 원소들을 가져온 후 각각의 값을 읽어 사용한다. flag 패키지를 이용할 때처럼 원하는 값을 직접 가져올 수 있고, 설정 파일을 통해 간접적으로 가져올 수도 있다.
- viper는 JSON,YAML,TOML,HCL, 자바 프로퍼티 포맷 등과 같이 포맷이 정해진 설정 파일을 사용할 때 파싱 작업을 viper가 모두 처리해준다. 또한 구조체에서 값을 가져오거나 저장하는 기능도 제공한다. 하지만 이렇게 하려면 Go 구조체 필드와 설정 파일의 키를 각각 대응할 수 있는 형태로 만들어야 한다.
- 일반적으로 코드 작성을 간결하게 해주는 방향으로 viper를 사용한다.
##### 커맨드라인 플래그사용 [/useViper]
- 두 개의 커맨드라인 매개변수를 받아 화면에 출력하는 간단한 유틸리티
##### JSON 설정 파일 읽기 [/jsonViper]
- viper 패키지를 이용해서 JSON 설정 파일을 읽는 방법

### 11. cobra 패키지
- cobra 패키지는 커맨드, 하위 커맨드, 앨리어스로 커맨드라인 유틸리티를 간편하게 개발하는 데 사용하는 인기 있는 Go패키지다. hugo, docker, kubectl을 써본 적이 있따면 cobra가 뭔지 금세 이해할 수 있다. 이 도구들이 cobra로 만들어졌기 때문이다. 커맨드는 한 개 이상의 앨리어스를 가질 수 있고 이 기능은 초보자와 경험이 있는 사람 모두 만족시킨다. 
- cobra는 모든 커맨드에 적용되는 퍼시스턴트 플래그뿐 아니라 특정 커맨드에만 지정할 수 있는 로컬 플래그도 지원한다. 또한 cobra는 커맨드라인 인수를 파싱할 때 기본적으로 viper를 사용한다.
- 모든 cobra는 일정한 개발 패턴을 따른다. cobra 도구를 사용할 때는 커맨드를 생성한 뒤 생성한 Go 소스코드에서 필요한 부분을 수정해 원하는 기능을 구현하는 방식을 사용한다. 

### 12. 유닉스 파일 시스템에서 순환 참조 찾기[/FScycles]
- 유닉스 파일 시스템에서는 심볼릭 링크를 이용하면 파일 시스템에 순환 참조가 생길수 있다. 이로 인해서 tar(1), find(1) 같은 유틸리티를 사용할 때 문제가 발생할 수 있고, 보안 관련 이슈가 발생할 수 있다. 순환 참조가 이뤄지고 있는지 찾는 실용적인 유닉스 유틸리티를 구현한다. 
- 해결방법은 방문한 모든 디렉터리 경로를 맵에 기록하고 해당 경로가 두 번 이상 나타난다면 사이클이 있다고 판단하는 것이다. 


### 13. Go 1.16의 새로운 기능(현재 버전 1.23.2)
- os.ReadDir() 함수, os.DirEntry 타입, io/fs 패키지

##### 파일 임베딩
- 임베딩한 파일의 데이터를 저장할 수 있는 타입은 string, []byte, embed.FS가 있다. 이 기능을 이용하면 Go 바이너리를 실행할 때 수동으로 파일을 다운로드할 필요가 없다.
- [/embedFiles] 에서는 주어진 커맨드라인 인수에 따라 두 가지 다른 파일을 검색할 수 있다.

##### ReadDir, DirEntry[/ReadDirEntry]
- io/ioutil 패키지가 사라졌다. io/ioutil 패키지의 기능은 다음처럼 다른 패키지로 옮겨졌다.
- 새로 추가된 os.ReadDir 함수는 []DirEntry를 반환한다. 따라서 []FileInfo를 반환하는 ioutil.ReadDir()을 직접 대체할 수는 없다. os.ReadDir()이나 os.DirEntry를 이용한다고 새 기능이 생긴 것은 아니지만 이를 이용하면 빠르고 간단하게 작업을 수행할 수 있다.
- os.ReadFile() 함수는 ioutil.ReadFile() 함수로 바로 대체할 수 있다.
- os.WriteFile() 함수는 ioutil.WriteFile() 함수로 바로 대체할 수 있다.
- os.MkdirTemp()는 ioutil.TempDir()을 아무 변경 없이 대체할 수 있다. 하지만 os.TempDir() 함수가 이미 있기 때문에 함수 이름이 바뀌었다.
- os.CreateTemp() 함수는 ioutil.TempFile()과 같다. os.TempFile() 함수가 있지는 않지만 Go의 개발자들은 os.MkdirTemp()와 이름을 맞추고자 os.CreateTemp()를 선택했다.
- [/ReadDirEntry] : os.ReadDir()의 사용법을 보여준다.(디렉터리의 크기를 계산한다.)
##### io/fs 패키지[/ioFS]
- io/fs에서는 FS라는 읽기 전용 인터페이스를 제공한다. 예를 들어 embed.FS는 fs.FS 인터페이스를 구현했기 때문에 io/fs 패키지에서 제공하는 기능들을 활용할 수 있다. 비슷하게 애플리케이션에서 직접 내부 파일 시스템을 만들어 사용할 수도 있다.