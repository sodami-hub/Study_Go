# ch07 - Go의 동시성
- Go 동시성 모델의 핵심 구성 요소는 Go의 최소 실행 단위인 고루틴이다. Go는 모든 것이 고루틴 형태로 실행된다. 모든 실행 가능한 Go 프로그램은 적어도 하나의 고루틴을 갖고 있으며, main 패키지의 main() 함수를 실행하는 데 사용한다. 
- 고루틴을 실행할 책임은 Go 스케줄러가 갖고 있고 각각의 고루틴은 스케줄러의 명령에 따라 하나의 운영체제 스레드에서 실행된다. 얼마나 많은 스레드를 생성할지는 운영체제 스케줄러에서 결정하지 않는다. 대신 Go 런타임에서 GOMAXPROCS 만큼의 스레드를 사용해 Go 코드를 실행할 수 있게 충분히 많은 스레드를 생성한다.
- 고루틴은 직접 통신할 수 없다. Go에서 데이터 공유는 채널이나 공유 메모리로 구현한다. 채널은 여러 고루틴을 연결하는 접착제처럼 동작한다. 
- 여러 개의 채널과 고루틴을 조합하면 데이터 흐름을 만들 수 있고 Go에서는 이를 파이프라인이라고 부른다. 데이터베이스에서 데이터를 읽어노는 고루틴이 있다면 채널을 통해 데이터를 두 번째 고루틴으로 전달한 후 데이터를 처리하고 다시 데이터베이스에 데이터를 저장하기 전에 처리한 데이터를 또 다른 채널을 통해 별도의 고루틴으로 전달할 수 있다.

### 프로세스, 스레드, 고루틴
- 프로세스 : 운영체제에서 실행 중인 프로그램, 프로그램은 프로세스를 생성할 때 필요한 정보를 담고 있는 디스크의 바이너리 파일
- 스레드 : 프로세스보다 좀 더 가볍고 작은 실행 단위. 프로세스는 하나 또는 그 이상의 스레드를 갖는다. 각 스레드는 제어 흐름과 스택을 따로 갖는다. 간단히 프로세스는 바이너리 파일을 실행한 것이고 스레드는 프로세스의 일부이다. 
- 고루틴 : Go 프로그램에서 동시에 실행할 수 있는 최소 단위이다. 고루틴은 독립적인 개체가 아니다. 고루틴은 유닉스 프로세스 안에 사는 스레드 안에 있다. 고루틴은 가볍다 하나의 컴퓨터에서 수천, 수만 개를 거뜬히 구동할 수 있다. 고루틴은 스택이 작고 생성 시간이 빠르며 적은 지연시간으로 채널을 통해 통신할 수 있기 때문에 스레드보다 가볍다.
- 하나의 프로세스가 여러 스레드로 구성되고 다시 여러 고루틴으로 구성된다. 고루틴은 자신이 속할 프로세스 환경이 있어야 된다. 프로세스와 스레드는 운영체제에서 관리해주지만 필요한 스레드는 Go가 생성해주고 개발자는 고루틴의 숫자를 관리해야 한다.

### Go 스케줄러
- 운영체제 커널의 스케줄러가 프로그램에 있는 스레드의 실행을 담당하듯이 Go 런타임에도 고루틴 실행을 담당하는 스케줄러가 있다. Go 스케줄러는 m:n 스케줄링 기법을 사용한다. m은 실행되는 고루틴의 개수이고 n은 고루틴을 멀티 플렉싱할 운영체제의 스레드 개수다. Go 스케줄러는 Go의 구성 요소로 Go 프로그램에 있는 고루틴의 실행 방법과 순서를 담당한다. 따라서 Go 스케줄러의 역할은 매우 중요하다. 스케줄러 또한 고루틴으로 시ㄹ행된다.
- 포크-조인 동시성 모델
- 균등 스케줄링 전략
- Go 스케줄러는 크게 OS 스레드(M)(현재 사용하는 OS에 따라 달라짐), 고루틴(G), 논리적 프로세서(P)라는 세 가지 개체에 의해 작동된다. Go 프로그램에서 사용할 수 있는 프로세서의 수는 GOMAXPROCS 환경 변수로 지정한다. 따라서 프로세서의 최대 개수는 GOMAXPROCS개다. 이제 Go의 m:n 스케줄링 알고리듬으로 돌아가보자. m개의 고루틴이 구동하게 되면 n개의 OS 스레드에서 스케줄링할 대상이 된다. 이때 논리적 프로세서를 최대 GOMAXPROCS개 사용한다. 
- Go 스케줄러는 필요에 따라 OS 스레드를 더 생성할 수 있다. 하지만 OS스레드는 상당히 무거운 편이다.
##### GOMAXPROCS 환경 변수 [/maxprocs]
##### 동시성과 병렬성
- 동시성과 병렬성은 같은 개념이 아니다. 병렬성은 특정한 여러 개체를 동시에 실행하는 것을 말하는 반면 동시성은 구성 요소들을 최대한 독립적으로 실행할 수 있게 구성하는 방식을 뜻한다. 소프트웨어 구성 요소를 구성할 때 동시성을 지원해야만 안전하게 병렬로 실행할 수 있다. 단, 하드웨어와 OS가 병렬성을 지원해야 한다. 
- 병렬성보다 동시성이 더 중요하다.

### 고루틴
- 고루틴을 정의하고 생성해서 실행하려면 go 키워드를 적고 그 뒤에 이어서 원하는 함수 이름이나 익명 함수를 적으면 된다. 함수를 호출하는 문장 앞에 go 키워드를 붙이면 그 함수는 즉시 반환하고 실제 동작은 백그라운드에서 고루틴형태로 실행되기 시작한다. 고루틴의 실행 순서는 예측하거나 제어할 수 없다.
##### 고루틴 생성[/create]
##### 고루틴 여러 개 생성[/multiple]
##### 고루틴이 끝날 때까지 기다리기[/varGoroutines]
- 여러개의 고루틴을 생성했다면, main() 함수가 고루틴들이 끝날 때까지 기다려야 한다. 동기화 프로세스는 sync.WaitGroup을 정의하고 Add(), Done(), Wait() 메서드를 사용하는 것부터 시작한다. sync 패키지, 특히 waitgroup.go를 살펴본다면 sync.WaitGroup 타입은 두 개의 필드를 갖고 있는 구조체일 뿐이라는 것을 알 수 있다.
```
type waitGroup struct {
    noCopy noCopy
    state1 [3]uint32
}
```
- 경쟁 상태를 피하고자 한다면 go 구문 앞에서 sync.Add()를 호출해야 한다는 점을 기억하자, 각각의 고루틴이 작업을 끝낼 때는 sync.Done() 함수를 호출해 똑같은 카운터를 감소시켜야 한다. sync.Done() 내부에서는 Add(-1)을 호출한다. Wait() 메서드는 카운터가 0이 될 때까지 기다린 뒤 반환한다.
- Add()가 Done()보다 많을 때 - 데드락에 빠진다. 메인함수가 고루틴을 영원히 기다린다. 카운트가 0이 되지 않음
- Done()이 Add()보다 많을 때 - 패닉이 된다.


### 채널
- 고루틴끼리 데이터를 주고받을 때 사용하는 통신 메커니즘이다. 먼저 각 채널마다 특정한 데이터 타입으로만 데이터를 교환할 수 있다. 이를 그 채널의 원소 타입이라고 한다. 둘째 채널이 정상적으로 작동하려면 채널로 데이터를 보내는 상대방이 있어야 한다. 채널을 선언한느 문장은 make()와 chan 키워드로 표시하고(make(chan int)) 채널을 닫으려면 close()함수를 호출해야 한다. make(chan int, 1) 처럼 채널의 크기를 선언할 수 있다.
- 파이프라인이란 고루틴과 채널을 연결하는 가상 메서드로, 채널을 통해 한쪽 고루틴에서 출력한 데이터를 다른 고루틴에 입력할 수 있다. 파이프라인을 사용하면 데이터의 흐름을 만들 수 있다. 또한 주고받는 값을 일일이 변수에 저장할 필요가 없어 변수 사용 횟수를 줄이고 결과적으로 메모리를 절약할 수 있다. 마지막으로 파이프라인을 사용하면 프로그램 설계가 간결해진다.
##### 채널에 데이터 쓰고 읽기[/channels]
- 채널 ch에 val을 쓰고 싶다면 그저 ch <-val 이라고 적으면 된다.여기서 화살표는 값을 보낼 방향을 나타내고 ch, val이 같은 타입이라면 문제없다. c라는 채널에서 하나의 값을 읽으려면 <-c 를 실행하면 된다. 여기서 방향은 채널에서 외부로 향하게 지정한다. 이 값을 aVar:=<-c 처럼 변수에 저장할 수도 있다.


### 경쟁 상태

### select 키워드

### 고루틴 시간 초과

### Go 채널 재방문

### 공유 메모리와 공유 변수

### 클로저 변수와 go 구문

### context 패키지

### semaphore 패키지